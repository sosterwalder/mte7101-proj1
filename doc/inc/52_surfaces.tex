% -*- coding: UTF-8 -*-
% vim: autoindent expandtab tabstop=4 sw=4 sts=4 filetype=tex
% chktex-file 27 - disable warning about missing include files

\section{Oberflächen}
\label{sec:surfaces}

Sofern nicht anders vermerkt, basiert der folgende Abschnitt
auf~\cite{division_introduction_1996}[S. 1 ff].\\
\\
Um in Computergrafiken überhaupt etwas darstellen zu können, muss erst einmal
definiert werden, was dargestellt werden soll. Häufig orientiert sich die
Computergrafik dabei an der realen Welt.  In der realen Welt haben Oberlächen
von Objekten häufig keine starken Übergänge (Kanten) sondern sind eher von
glatter Natur~\cite{foley_computer_1996}[S. 471].\\
\\
Die Darstellung von Kurven und Oberflächen führt zu zwei Fällen: Modellierung
von bestehenden Objekten und Modellierung von Grund auf.\\
\\
Zur Modellierung von Oberflächen werden hauptsächlich zwei Techniken verwendet:
Parametrische Modellierung und implizite Modellierung.\\
\\
Bei der parametrsichen Darstellung wird eine Oberfläche überlicherweise als
eine Menge von Punkten definiert, so zum Beispiel:

\todo[inline]{Provide example by means of a sphere}

\begin{gather}\label{eq:surface_parametric}
    \bm{p}(s, t) = (x(s, t), y(s, t), z(s, t))
\end{gather}

Bei der impliziten Darstellung wird eine Oberfläche überlicherweise als Kontur
einer Funktion mit Wert 0 definiert, so zum Beispiel:

\begin{gather}\label{eq:surface_implicit}
    f(\bm{p}) = f(x, y, z) = 0
\end{gather}

Die parametrische Darstellung bringt Vorteile wie die Unabhängigkeit von einem
Koordinatensystem oder eine effiziente Berechnung von Punkten auf einer
Oberfläche. Die implizite Darstellung erlaubt hingegen eine grössere
Einflussnahme aus mathematischer Sicht und ist daher sehr nützlich für
Operationen wie Biegung, Vermischung, Schnitte (Intersektion) oder Bool'sche
Operationen.

\subsection{Implizite Oberflächen}
\label{subsec:implicit_surfaces}

Wie in Gleichung~\ref{eq:surface_parametric} beschrieben, ist eine implizite
Oberfläche gemäss~\cite{hart_ray_1993}[S. 1] als Funktion $ f(\bm{x}) =
\mathbb{R}^{3} \to \mathbb{R} $ definiert.  Es wird also jedem Punkt einer
Menge $ \bm{p} \in \mathbb{R}^{3} $ ein skalarer Wert $ s \in \mathbb{R} $
zugewiesen. Dabei besteht die Oberfläche aus der Punktemenge $ \bm{x} \equiv
(x, y, z) \in \mathbb{R}^{3} $.\\
\\
Angenommen $ \bm{A} $ ist ein geschlossener Festkörper, welcher durch die
Funktion $f$ beschrieben wird, dann kann gemäss~\cite{hart_ray_1993} Folgendes
angenommen werden:

\begin{align} \label{eq:surface_implicit_condition}
    x \in \overset{\circ}{\bm{A}} \Leftrightarrow f(\bm{x}) &< 0 \\
    x \in \partial \bm{A}         \Leftrightarrow f(\bm{x}) &= 0 \\
    x \in \mathbb{R}^{3} - \bm{A} \Leftrightarrow f(\bm{x}) &> 0
\end{align}

Dies bedeutet, dass sich ein Punkt $\bm{x}$:
\begin{itemize}
    \item $\overset{\circ}{\bm{A}}$, genau dann \textit{innerhalb} des Körpers
        $\bm{A}$ befindet, wenn die implizite Funktion $f(\bm{x})$ \textit{negativ}
        ist
    \item $\partial{\bm{A}}$, genau dann \textit{auf der Oberfläche} des
        Körpers $\bm{A}$ befindet, wenn die implizite Funktion $f(\bm{x})$
        \textit{0} ist
    \item $\mathbb{R}^{3} - \bm{A}$, \textit{nicht in oder auf} dem Körper
        $\bm{A}$ befindet, wenn die implizite Funktion $f(\bm{x})$ \textit{positiv}
        ist
\end{itemize}

Dies gilt, da es sich bei $ \bm{x} $ um eine Punktemenge mit topologischer
Struktur handelt.\\
\\
Gemäss~\cite{division_introduction_1996} finden hauptsächlich drei Methoden
Anwendung zur Beschreibung impliziter Oberflächen: algebraische Oberflächen,
Blobby-Objekte sowie die funktionale Repräsentation.~\cite{hart_sphere_1994}
gibt jedoch an, dass die gebräuchlichste Form von impliziten Oberflächen die
algebraischen Oberflächen sind. Diese werden implizit durch polynomiale
Funktionen definiert.\\

\subsubsection{Algebraische und geometrische implizite Oberflächen}
\label{ssubsec:implicit_surfaces_algebraic_geometric}

Ein Beispiel für eine algebraische Oberfläche ist die Beschreibung der
Einheitskugel anhand einer impliziten algebraischen Gleichung zweiten Grades:

\begin{gather} \label{eq:surface_immplicit_algebraic}
    x^{2} + y^{2} + z^{2} - 1 = 0
\end{gather}

Wobei es sich bei dem letzten Parameter um den Radius $r$ handelt, welcher ---
bedingt durch die Einheitskugel --- den Wert 1 hat.

Wie~\cite{division_introduction_1996} schreibt, handelt es sich bei impliziten
Oberflächen, welche durch eine polynomiale Funktion zweiten Grades beschrieben
werden, um quadrische implizite Oberflächen.

\cite{hart_sphere_1994} gibt weiter an, dass --- unter Nuztung einer Metrik ---
die Einheitskugel durch die implizite Gleichung

\begin{gather} \label{eq:surface_immplicit_geometric}
    \|\bm{x}\| - 1 = 0
\end{gather}

beschrieben werden kann, was unter Anwendung der allgemeinen
Form~\ref{eq:surface_implicit} einer impliziten
Gleichung~\ref{eq:surface_implicit} zu folgender Gleichung führt:

\begin{gather}\label{eq:surface_implicit_sphere}
    f(\bm{x}) = \|\bm{x}\| - 1
\end{gather}

\todo[inline]{Change notation}  %(x^2 + y^2 + z^2)^{1/2}% as this allows the usage of any basis, e.g.\ ln

Dabei ist $\|\bm{x}\|$ als euklidische Metrik definiert und entspricht $\sqrt{x^{2} + y^{2} + z^{2}}$.\\
\\
Die Gleichung~\ref{eq:surface_immplicit_algebraic} gibt die algebraische
Distanz zurück, Gleichung~\ref{eq:surface_immplicit_geometric} gibt die
geometrische Distanz zurück.\\

\subsubsection{Distanzfunktionen}
\label{ssubsec:distance_functions}

Gemäss~\cite{hart_sphere_1994} wird die geometrische Darstellung von
quadrischen Oberflächen bevorzugt, da deren Parameter unabhängig von
Koordinaten sind, sie robuster und intuitiver sind. Es handelt sich dabei um
eine \textbf{Distanzfunktion}.\\
\\
Wie anfangs erwähnt, definiert~\cite{hart_sphere_1994} die allgemeine Form zur
Beschreibung bzw. Darstellung von impliziter Oberflächen als Zuweisung von
Punkten zu einem skalaren Wert: $ f : \mathbb{R}^{n} \to \mathbb{R} $.\\
\\
Unter Anwendung der unter~\ref{eq:surface_implicit_condition} definierten
Bedingungen kann geschlossen werden, dass eine Menge von Punkten $A$ existiert,
welche Teil von $\mathbb{R}^{n}$, also $A \subset \mathbb{R}^{n}$ ist. Dies heisst, dass alle Punkte in $A$ die folgende Bedingung erfüllen:

\begin{gather}
    A = \{ x : f(x) \leq 0 \}
\end{gather}

\cite{hart_sphere_1994} liefert zwei Definition, welche der Beschreibung von Distanzfunktionen dienen:

\theoremstyle{definition}
\begin{definition}{\label{theo:point_to_set_distance}
    \textit{Point-to-set distance}}\\
    Die Distanz eines Punktes zu einer Menge von Punkten definiert die Distanz
    eines Punktes $ \bm{x} \in \mathbb{R}^{3} $ zu einer Menge von Punkten $A
    \subset \mathbb{R}^{3}$ als Distanz von $\bm{x}$ zum nähesten Punkt in $A$:

    \begin{gather}
        d(\bm{x}, \bm{A}) = \min_{\substack{\bm{y} \in \bm{A}}}(\|\bm{x} - \bm{y}\|)
    \end{gather}
\end{definition}

\theoremstyle{definition}
\begin{definition}{\label{theo:signed_distnace_bound}
    \textit{Signed distance bound}}\\ 
    Eine Funktion $ f : \mathbb{R}^{3} \to \mathbb{R} $ ist eine
    vorzeichenabhängige Obergrenze ihrer impliziten Oberfläche $ f^{-1}(0)$,
    wenn gilt:

    \begin{gather}\label{eq:signed_distnace_bound}
        |f(\bm{x})| \leq d(\bm{x}, f^{-1}(0))
    \end{gather}
\end{definition}

Wenn die Gleichung~\ref{eq:signed_distnace_bound} für eine Funktion $f$ gilt,
dann ist $f$ eine \textit{vorzeichenabhängige Distanzfunktion (signed distance
    function)}.

\subsubsection{Distanzfelder (distance fields)}
\label{ssubsec:distance_fields}

\todo[inline]{Introduce distance fields?}

\section{Darstellung von impliziten Oberflächen}
\label{sec:rendering_implicit_surfaces}

Wie~\cite{hart_sphere_1994}[S. 1] angibt, existieren verschiedene Möglichkeiten
zur Darstellung (zum Rendering) von impliziten Oberflächen. So wandeln
indirekte Methoden implizite Oberflächen in Polygonmodelle um, was die Nuztung
bestehender Techniken und Hardware zur Darstellung von polygonalen Modellen
erlaubt. Obwohl die Umwandlung der impliziten Oberflächen mit gängigen Systemen
zur Darstellung problemlos dargestellt werden kann, ist die Umwandlung jedoch nicht
in jedem Fall gegeben und kann zu nicht zusammenhängenden Flächen oder einer
Verminderung des Detailgrades führen.\\
\\
Eine andere Methode zur Darstellung von impliziten Oberflächen ist das
unter~\ref{sec:ray_tracing} vorgestellte Ray Tracing Verfahren.

Ein (Licht-) Strahl wird dabei parametrisch als

\begin{gather}\label{eq:ray_param}
    r(t) = r_{0} + t \cdot r_{d}
\end{gather}

beschrieben. Der Strahl startet dabei bei Punkt $r_{0}$ in Richtung des
Einheitsvektors $r_{d}$, wobei $t$ die zurückgelegte Distanz des Strahles ist.
Dabei ist $r(t)$ der Punkt im Raum, welchen der Strahl nach dem Zurücklegen der
Distanz $t$ --- ausgehend von seinem Ursprung $r_{0}$ --- erreicht.\\
\\
Um nun die Schnittpunkte eines Strahles mit einer impliziten Oberfläche zu finden, wird die Gleichung des Lichtstrahles $r$ (\ref{eq:ray_param}) in die Funktion einer impliziten Oberfläche $f$ (\ref{eq:surface_implicit}) eingesetzt. Wobei $r : \mathbb{R} \to \mathbb{R}^{3}$ und $f : \mathbb{R}^{3} \to \mathbb{R}$. Dies ergibt die zusammengesetzte Funktion $F = f \circ r$ wobei $F : \mathbb{R} \to \mathbb{R}$.\\
\\
Die Lösungen dieser Gleichung sind alle Distanzen $t$, welche ein gegebener Strahl zurücklegt und welche die folgende Bedingung erfüllen:

\begin{gather}\label{eq:ray_param_cond}
    F(t) = f \circ r = f(r(t)) = 0
\end{gather}

Um die Gleichung~\ref{eq:ray_param_cond} zu lösen, können numerische Verfahren
zur Nullstellensuche angewendet werden, wobei die Verfahren vom Typ der
Funktion $F(t)$ abhängig sind. Bei polynomialen Funktionen bis zum vierten Grad
existieren analytische Lösungen, für eine beliebige Funktion muss jedoch ein
generisches, robustes Verfahren zur Nullstellensuche verwendet werden. Dies
bedingt jedoch meist, dass mehr Informationen über die Funktion zur Verfügung
stehen, was beispielsweise durch Ableiten dieser gelöst werden kann.\\
\\
Die erwähnten Verfahren zur Nullstellensuche haben jedoch häufig den Nachteil,
dass sie mehrere Schnittpunkte eines Strahles mit einer impliziten Oberfläche
liefern. Um diese Problematik zu umgehen, wird nur der kleinste Wert von $t$
berücksichtigt. Die Ray Marching und Sphere Tracing Algorithmen gehen hier
sogar noch einen Schritt weiter, in dem sie nur die kleinste positive
Nullstelle der Gleichung~\ref{eq:ray_param_cond} betrachten.

\subsection{Ray Marching}
\label{subsec:ray_marching}

~\cite{perlin_hypertexture_1989} schlagen eine Abtastung des Strahles mit fixen
Abständen $\Delta \mu$ vor:

\begin{gather}
    x = x_{\mu_{0}} + k \cdot \Delta x_{\mu}
\end{gather}

wobei $k = 0,1,2,\dots$ und $\mu_{0} + k \Delta \mu \leq \mu_{1}$.\\
\\
Auf die parametrische Darstellung eines (Licht-) Strahles,
Gleichung~\ref{eq:ray_param_cond}, angwendet:

\begin{gather}
    r(k) = r_{0} + \Delta t \cdot k \cdot r_{d}
\end{gather}

wobei $\Delta t$ die Grösse der Abstände und $k = 0,1,2,\dots$ die Nummer der
Schritte darstellt. Wie~\cite{hart_ray_1989} schreiben, bildet das Abtasten des
(Licht-) Strahles mit fixen Abständen die Basis für gewisse Verfahren des
volumetrischen Renderings.\\
\\
Ein möglicher Algorithmus, wie solch ein Verfahren umgesetzt werden kann,
findet sich in~\ref{fig:ray_marching}.

\begin{lstlisting}[language=Python,caption={Eine abstrakte Umsetzung des Ray
        Marchings\protect\footnotemark.},label={fig:ray_marching},captionpos=b,emph={ray_march}]
def ray_march():
    step         = 0
    intersection = 0
    max_steps    = 10

    while step < max_steps:
        intersection = test_intersection(k)

        if intersection <= 0:
            # An intersection has happened
            #   intersection <  0: ray is inside surface
            #   intersection == 0: ray is excatly on surface
            return ray_travel_distance(step)

        step = step + 1

    # When we reach this step, after max_steps, no intersection
    # has happened, so distance is 0
    return 0
\end{lstlisting}
\footnotetext{Algorithmus in Pseudocode
    gemäss~\cite{perlin_hypertexture_1989}[S. 259, Abschnitt 3.1]}

Dabei ist jedoch zu beachten, dass der Abstand zur Abtastung eines Strahles
$\Delta t$ so gering als möglich sein sollte um eine Punktemeng bzw.\ ein
Objekt --- definiert durch implizite Oberflächen --- $A$ möglichst gut
abschätzen zu können. Ist der gewählte Abstand zu gross gewählt, so findet ggf.
eine Abtastung weit im Inneren des Objektes statt und somit geht Präzision
verloren.  Es ist auch möglich dass der erste eigentliche Punkt gar nicht
abgetastet wird und erst der zweite abgetastete Punkt das Objekt ``erkennt''.
Die Grafik~\todo{insert reference to image here} veranschaulicht diese
Problematiken.\\
\\
\todo[inline]{Provide illustration for ray marching}

\cite{hart_sphere_1994} weist darauf hin, dass Ray Marching durch den möglichst
geringen Abstand zwischen den Abtastungen entsprechend langsam und paralleles
Abtasten praktisch unumgänglich ist. In der von~\cite{hart_sphere_1994}
vorgestellten Technik des Sphere Tracings ist der Abstand zwischen den
Abtastungen nicht konstant sondern variiert in Abhängigkeit der Geometrie.

\subsection{Sphere Tracing}
\label{subsec:sphere_tracing}

Das von~\cite{hart_sphere_1994} vorgestellte Sphere Tracing Verfahren ist ein
Ray Tracing (\ref{sec:ray_tracing}) Verfahren für implizite Oberflächen. Es
handelt sich nach wie vor um Ray Marching (\ref{subsec:ray_marching}), die
Distanz der Schritte zum Abtastens  eines (Licht-) Strahles wird jedoch
aufgrund einer Distanzfunktion (\ref{ssubsec:distance_functions}) bestimmt.\\
\\
\cite{hart_sphere_1994} verweist auf den Term \textit{``unbounding volumes''},
welcher in~\cite{hart_ray_1989} eingeführt wurde. ``Unbounding volumes'' (zu
Deutsch etwa ``negativer Hüllkörper'') wird genutzt um Sphere Tracing zu
beschreiben und darzustellen. Der Term steht im Gegensatz zu dem gängigen
Konzept des Hüllkörpers (``bounding volumes'') --- ein Volumen, welches einen
Körper umschliesst. Ein ``negativer Hüllkörper'' (``unbounding volume'')
umschliesst also eine Fläche im Raum, welche den Körper \textit{nicht}
beinhaltet.\\
\\
Man möchte für einen abzutastenden Punkt im Raum ein Volumen finden, wessen
Zentrum im abzutastenden Punkt liegt. Ist der Abstand des Punktes zum nähesten
Punkt der Oberfläche eines Objektes bekannt, kann dieser Abstand als Radius
einer Kugel angenommen werden. Diese Kugel dient als negativer Hüllkörper
(``unbounding Volume'') und ist \textit{garantiert nicht} Teil des Objektes und
schneidet dieses auch nicht (ist also nicht $\overset{\circ}{\bm{A}}$) --- nur
der äusserste Punkt des Abstandes (also des Radius der Kugel) liegt genau auf
der Oberfläche des Objektes ($\partial \bm{A}$). Der Radius solch einer Kugel
wird durch Evaluation der Distanzfunktion eines abzutastenden Punktes im Raum
bestimmt.\\
\\
Gemäss~\cite{hart_sphere_1994} kommt daher auch der Name Sphere Tracing: Die
Schnittpunkte eines (Licht-) Strahles werden durch eine Folge von negativen
Hüllkörper (``unbounding volumes'') --- bzw.\ in diesem Fall Kugeln
(``unbounding spheres'') --- beschrieben.\\
\\
Da~\cite{hart_ray_1989} die Darstellung von Fraktale im dreidimensionalen Raum
beschreibt, wird dort von einer Abschätzung der Distanz gesprochen. Dies ist
dadurch bedingt, dass die Distanz für Fraktale nicht effizient berechnet werden
kann. Betrachtet man jedoch die Darstellung von  ``regulären'' Objekten, wie zum
Beispiel eine Kugel, kann der zur Oberfläche am nähesten gelegene Punkt von
einem beliebigen Punkt derselben Domäne exakt berechnet werden. Dies ist durch
die implizite Gleichung~\ref{eq:surface_implicit_sphere} gegeben.\\
\\
Gemäss~\cite{hart_ray_1989} verläuft die Strahlenverfolgung bei dem Sphere
Tracing Verfahren wie folgt. Ein Strahl wird vom Betrachter (Auge bzw.
Lochkamera) durch die Bildebene zu einem Objekt geschossen. Dabei wird beim
initialen Augangspunkt der Radius eines negativen Hüllkörpers in Form einer
Kugel --- so wie oben beschrieben --- berechnet. Dies ist die Distanz, welcher
der Strahl in einem ersten Schritt effektiv zurücklegen wird. Bei jedem
Schnittpunkt der Kugel mit dem Strahl wird dasselbe Verfahren wiederholt. Dies
geschieht so lange, bis schliesslich der Strahl durch einen Schnittpunkt mit
einem Radius auf die Oberfläche des Objektes trifft. Ein weiteres
Abbruchkriterium ist eine definierte maximale Distanz eines Strahles. Ist diese
erreicht und der Strahl erreicht die Oberfläche des Objektes nicht --- weil der
Strahl das Objekt nicht schneidet oder das Objekt zu weit weg ist ---, wird
abgebrochen. Somit ist auch ersichtlich, dass Sphere Tracing nicht die
unter~\ref{subsec:ray_marching} genannten Problematiken aufweist.\\
\\
\todo[inline]{Provide illustration for sphere tracing}

Ausgehend von der parametrischen Beschreibung eines (Licht-) Strahles
(Gleichung~\ref{eq:ray_param}), beschreibt~\cite{hart_sphere_1994} die Richtung
$r_{d}$ eines Strahles als Einheitsvektor:

\begin{gather}
    r_{d} = \frac{p_{x, y} - r_{0}}{|p_{x, y} - r_{0}|}
\end{gather}

wobei $r_{0}$ der Ursprung eines Strahles und $p_{x, y}$ ein Punkt der Bildebene ist.\\
\\
Um nun den Schnittpunkt eines Strahles $r_{d}$ mit der Oberfläche eines
Objektes zu finden, muss die Gleichung $F(t)$ (\ref{eq:ray_param_cond}) gelöst
werden. Dabei ist --- wie oben definiert --- die Funktion $f(x)$ nun eine
Distanzfunktion wie die geometrische Distanzfunktion zur Beschreibung einer
Kugel (Gleichung~\ref{eq:surface_immplicit_geometric}).\\
\\
Evaluiert man nun die Gleichung $F(t)$ unter Anwendung der eben beschriebenen
Strahlenverfolgung, findet man so die erste positive Nullstelle der Gleichung
$F(t)$. Diese Nullstelle ist die Grenze der Folge von negativen Hüllkörpern
(``unbounding spheres''), welche durch die rekursive Gleichung

\begin{gather}
    t_{i+1} = t_{i} + F(t_{i})
\end{gather}

definiert ist. Der Ursprungspunkt ist dabei als $t_{0}$ definiert. Diese Folge
konvergiert genau dann --- und nur dann --, wenn der Strahl auf die implizite
Oberfläche eines Objkektes trifft. Diese Folge bildet den Kern des Algorithmus
zur Darstellung von geometrisch definierten, impliziten Oberflächen.

\begin{lstlisting}[language=Python,caption={Eine abstrakte Umsetzung des Sphere
        Tracings\protect\footnotemark.},label={fig:sphere_tracing},captionpos=b,emph={sphere_trace}]
def sphere_trace():
    ray_distance          = 0
    estimated_distance    = 0
    max_distance          = 9001
    convergence_precision = 0.000001

    while ray_distance < max_distance:
        # sd_sphere is a signed distance function defining the implicit surface
        # cast_ray defines the ray equation given the current travelled /
        # marched distance of the ray
        estimated_distance = sd_sphere(cast_ray(ray_distance))

        if estimated_distance < convergence_precision:
            # the estimated distance is already smaller than the desired
            # precision of the convergence, so return the distance the ray has
            # travelled as we have an intersection
            return ray_distance

        ray_distance = ray_distance + estimated_distance

    # When we reach this point, there was no intersection between the ray and a
    # implicit surface, so simply return 0
    return 0
\end{lstlisting}
\footnotetext{Algorithmus in Pseudocode gemäss~\cite{hart_sphere_1994}[S. 531,
    Fig. 1]}
