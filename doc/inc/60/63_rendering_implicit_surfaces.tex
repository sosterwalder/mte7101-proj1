% -*- coding: UTF-8 -*-
% vim: autoindent expandtab tabstop=4 sw=4 sts=4 filetype=tex
% chktex-file 27 - disable warning about missing include files

\section{Rendering von impliziten Oberflächen}
\label{sec:rendering_implicit_surfaces}

Nachdem in den vorherigen Abschnitten Methoden zur Modellierung von
Oberflächen behandelt wurden, zeigt folgendes Kapitel wie implizite
Oberflächen gerendert werden
können.~\citeauthor{glassner_introduction_1989 } beschreibt Rendering
als Erstellung von Bildern ausgehend von
Modellen.~\cite{glassner_introduction_1989}[S. 606]

\subsection{Beleuchtungsmodell}
\label{sec:rendering_implicit_surfaces_lighting}

Um implizite Oberflächen darstellen zu können, ist es notwendig ein
Beleuchtungsmodell zu wählen. Ansonsten wäre das dargestellte Bild nur schwarz.
Der Einfachheit halber wird im Rahmen dieser Projektarbeit das in
Kapitel~\ref{subsec:local_illumination_models} vorgestellte
Phong-Beleuchtungsmodell verwendet.

Daher wird die resultierende Farbe eines Punktes im Raum $I(\bm{x})$ aus
ambienten, diffusen und reflektierenden Anteilen berechnet:

\begin{gather}
    I(\bm{x}) = I_{\text{ambient}} + I_{\text{diffuse}} + I_{\text{specular}}
\end{gather}

Wie bereits zuvor in Kapitel~\ref{subsec:local_illumination_models} erwähnt,
wird der emissive Term bewusst weggelassen, da keine emissiven Materialen
dargestellt werden sollen. Als Lichtquelle wird eine einzelne direktionale
Lichtquelle gewählt. Analog zu den vorherigen Abschnitten ist $\bm{x}$
in den folgenden Abschnitten ein Punkt $(x, y, z)$ auf einer impliziten
Oberfläche $A$.

Der \textit{ambiente Anteil} $I_{\text{ambient}}$ ergibt sich dann wie
folgt:

\begin{gather}
    \text{I}_{\text{ambient}} = k_{\text{ambient}}(\bm{x}) \cdot L_{\text{ambient}}
\end{gather}

wobei $k_{\text{ambient}}(\bm{x})$ den ambienten Faktor des
Punktes $\bm{x}$ und $L_{\text{ambient}}$ die Farbe des eingehenden ambienten
Lichtes ist.

Der \textit{diffuse Anteil} $I_{\text{diffuse}}$ ergibt sich wie folgt:

\begin{gather}
    I_{\text{diffuse}} = k_{\text{diffuse}}(\bm{x}) \cdot L_{\text{diffuse}} \cdot \max(\bm{n} \cdot \bm{l}, 0)
\end{gather}

wobei $k_{\text{diffuse}}(\bm{x})$ den diffusen Faktor am Punkt $\bm{x}$
und $L_{\text{diffuse}}$ die Farbe des eingehenden diffusen Lichtes ist.
Die Richtung der Lichtquelle, ausgehend von Punkt $\bm{x}$, ergibt sich
durch das Punktprodukt zwischen der Einheitsnormalen $\bm{n}$ des
Punktes und dem Einheitsvektor $\bm{l}$.

Der \textit{reflektierende Anteil} $I_{\text{specular}}$ ergibt sich
wie folgt:

\begin{gather}
    I_{\text{specular}} = n_{\text{facing}} \cdot k_{s}(\bm{x}) \cdot L_{\text{specular}} \cdot \max{(\bm{n} \cdot \bm{h}, 0)}^{k_{e}}
\end{gather}

wobei $k_{\text{specular}}(\bm{x})$ den reflektierenden Faktor des
Punktes $\bm{x}$ und $L_{\text{specular}}$ die Farbe des eingehenden
reflektierenden Lichtes ist. Bei $\bm{h}$ handelt es sich um einen
Einheitsvektor, welcher in der Hälfte zwischen der Blickrichtung des
Betrachters bzw.\ der Kamera ($\vv{V}$) und $\bm{l}$ der Richtung der
Lichtquelle ausgehend von dem Punkt $\bm{x}$ ist. Der Exponent $k_{e}$
gibt an, wie rau bzw.\ wie spiegelnd die Oberfläche am Punkt $\bm{x}$
ist. Der Faktor $n_{\text{facing}}$ definiert, ob die Oberfläche
überhaupt einen reflektierenden Anteil hat:

\begin{equation}
    n_{\text{facing}} = \begin{cases}
        0 & \quad \text{if } \bm{n} \cdot \bm{l} \leq 0\\
        1 & \quad \text{if } \bm{n} \cdot \bm{l} > 0 \\
    \end{cases}
\end{equation}

Für die Berechnung der Lichtintensität bzw.\ der Farbe einer Oberfläche
wird die Normale der Oberfläche benötigt. Gemäss~\cite{hart_ray_1989}
kann diese mittels des Gradienten des Distanzfeldes
eines Punktes einer impliziten Oberfläche berechnet werden:

\begin{gather}
    \bm{n}_{x} = f(x + \varepsilon, y, z) - f(x - \varepsilon, y, z) \\
    \bm{n}_{y} = f(x, y + \varepsilon,  z) - f(x, y - \varepsilon,  z) \\
    \bm{n}_{z} = f(x, y, z + \varepsilon) - f(x, y, z - \varepsilon) \\
\end{gather}

wobei $\bm{n} = \begin{bmatrix} x_{n} \\ y_{n} \\ z_{n} \end{bmatrix}$
die Normale der Oberfläche in Form eines Vektors, und $f$ eine
Distanzfunktion ist.

Der Gradient einer Funktion $f: \mathbb{R}^{n} \to \mathbb{R}$ wird wie
folgt berechnet:

\begin{gather}
    \text{grad} f = \nabla f = \begin{bmatrix}
        \frac{\partial f}{\partial x_{1}} \\
        \frac{\partial f}{\partial x_{2}} \\
        \vdots \\
        \frac{\partial f}{\partial x_{n}} 
    \end{bmatrix}\\
    \text{grad} f = f_{x}\bm{i} + f_{y}\bm{j} + f_{z}\bm{k}\\
\end{gather}

\cite{hart_ray_1989} gibt dabei $\varepsilon$ als die minimale
Inkrementation eines (Licht-) Strahles an und definiert diesen als
Sichtbarkeitsfunktion $\Gamma_{\alpha, \delta}$:

\begin{gather}
    \Gamma(d) = \alpha d^{\delta}
\end{gather}

in Abhängikeit der euklidischen Distanz
$d$ des Betrachters / der Kamera zur aktuellen Position des (Licht-)
Strahles:

\begin{gather}
    d = |r_{\bm{n}} - r_{0}|
\end{gather}

wobei $\delta$ ein so genannter ``depth-cueing''-Exponent
(``depth-cueing'' oder auch ``foldback'', ``a process for returning a
signal to a performer
instantly''~\cite{liam_collins_sons_&_co._ltd._collins_2015}) und
$\alpha$ ein empirischer Anteil, welcher die Tiefenauflösung des
Objektes definiert,
ist.
Details dazu finden sich unter~\cite{hart_ray_1989}[S. 293, Abschnitt
4.2 --- ``Clarity''].

Es folgt also:

\begin{gather}
    \varepsilon = \Gamma_{\alpha, \delta}(|r_{\bm{n}} - r_0|)
\end{gather}

Die Korrektheit der Berechnung der Normalen $\bm{n}$ hängt von der
Grösse von $\varepsilon$ ab. Daher wird für gewöhnlich ein kleiner Wert
für $\varepsilon$ gewählt.

Die Normale der Oberfläche sollte schliesslich noch normalisiert werden.

\cite{hart_ray_1989} schreibt weiter, dass die oben genannte Gradiente,
bestehend aus 6 Punkten, durch Hinzunahme von Punkten, welche eine
gemeinsame Kante haben, erweitert werden kann. Dies erzeugt eine
Gradiente bestehend aus 18 Punkten. Werden noch die Punkte
hinzugenommen, welche gemeinsame Eckpunkte haben, so ergibt sich eine
Gradiente bestehend aus 26 Punkten.
Dies macht jedoch nur dann Sinn, wenn die Gradiente mit 6 Punkten eine
unzureichende Genauigkeit liefert.

\subsection{Rendering}
\label{sec:rendering_implicit_surfaces_Rendering}

Um implizite Oberflächen zu rendern werden die in
Abschnitt~\ref{subsec:implicit_surfaces_primitives} angegebenen
Primitiven verwendet.

Zum eigentlichen Rendern wird der Algorithmus~\ref{alg:sphere_tracing}
mit dem unter Abschnitt~\ref{sec:rendering_implicit_surfaces_lighting}
angegebenen Beleuchtungsmodell angwendet.

\subsection{Schatten}
\label{sec:rendering_implicit_surfaces_shadows}

Sofern nicht anders vermerkt, basiert folgender Abschnitt
auf~\cite{reiner_smi_2011}[S. 7].

Mittels Sphere Tracing können Schatten analog den vom Ray Tracing
bekannten Verfahren gewonnen werden. Dazu werden Schattenfühler
(``shadow rays'') mit Sphere Tracing abgetastet. Man bildet also eine
Folge von negativen Hüllkörpern (``unbounding volumes'') bzw. Kugeln
(``unbounding spheres'') pro Lichtquelle in Richtung dieser ausgehend
von einem Punkt einer Oberfläche. Die Folge wird so lange fortgesetzt,
bis eine Intersektion stattfindet oder bis eine definierte maximale
Distanz erreicht wurde.

\begin{gather}
    r_{s}(t) = \bm{x} + t \cdot r_{l}
\end{gather}

wobei $r_{s}(t)$ der Ursprung des Schattenfühlers am Punkt $\bm{x}$
einer impliziten Oberfläche und $r_{l}$ die Richtung des
Schattenfühlers in Form eines Einheitsvektors ist.

\begin{lstlisting}[language=Python,caption={Algorithmus zur Berechnung
        von Schatten.},label={alg:sphere_tracing_shadows},captionpos=b,emph={calc_shadows}]
def calc_shadows():
    min_distance          = 0.01
    max_distance          = 9001
    shadow_ray_distance   = min_distance
    estimated_distance    = 0
    convergence_precision = 0.000001

    while shadow_ray_distance < max_distance:
        # sd_sphere is a signed distance function defining the implicit surface
        # cast_ray defines the ray equation given the current travelled /
        # marched distance of the ray
        estimated_distance = sd_sphere(cast_ray(shadow_ray_distance))

        if estimated_distance < convergence_precision:
            # the estimated distance is already smaller than the desired
            # precision of the convergence, so return zero (0) as we
            # have an intersection and therefore shadows
            return 0

        shadow_ray_distance = shadow_ray_distance + estimated_distance

    # When we reach this point, there was no intersection between the ray and a
    # implicit surface, so no shadows, so simply return 1
    return 1
\end{lstlisting}

Der Algorithmus~\ref{alg:sphere_tracing_shadows} ist dem des Sphere
Tracings~\ref{alg:sphere_tracing} sehr ähnlich, der Rückgabewert ist
jedoch komplett verschieden. Der Algorithmus gibt den Wert 1 zurück,
wenn keine Intersektion zwischen dem  Schattenfühler und einer
Oberfläche stattfand nachdem die maximale Distanz erreicht wurde. Der
Wert 0 wird zurückgegeben, wenn der Schattenfühler auf eine Oberfläche
getroffen ist und der Punkt $\bm{x}$ einer impliziten Oberfläche sich
daher im Schatten befindet.

Um zu verhindern, dass ein Punkt $\bm{x}$ einer impliziten Oberfläche
sich selbst verdeckt (sich selbst Schatten spendet), wird die initial
zurückgelegte Distanz~\textit{shadow\_ray\_distance} auf einen Minimalwert
\textit{min\_distance} gesetzt. Dieser Wert sollte jedoch wesentlich
grösser als die gewünschte Präzision \textit{convergence\_precision}
sein, da ansonsten die Bedingung \textit{estimated\_distance <
    convergence\_precision} ggf.\ initial erfüllt und sich der Punkt $\bm{x}$
daher immer im Schatten befinden würde.

\citeauthor{reiner_smi_2011} geben zudem an, wie weiche Schatten mittels
Sphere Tracing relativ einfach dargestellt werden können. Während der
Expansion anhand des Schattenfühlers wird die minimale, evaulierte
Distanz $d_{\text{min}}$ zu einem beliebigen Objekt gespeichert. Es wird
dabei angenommen, dass sich ein Punkt $\bm{x}$ einer impliziten
Oberfläche für schmale Distanzen $ 0 < d_{\text{min}} < d $ im Schatten
befindet. Somit ergibt schliesslich das Verhältnis der minimalen Distanz
zu der aktuellen Distanz einen Schatten- bzw.  Penumbra-Faktor:
$\text{shadow} = {d_{\text{min}} \over d}$, wobei $\text{shadow} \in (0,
1)$. Mit wachsender Distanz $d$ wächst auch die so genannte
Penumbra-Region.

Durch Speichern der minimalen, evaluierten Distanz ist es möglich die
Distanz des Schattenfühlers zu der ihn umgebenden Geometrie zu
untersuchen und somit die Penumbra-Region sowie weiche Schatten zu
bestimmen. Befindet sich der Schattenfühler in der Nähe einer
Oberfläche, schneidet diese aber nicht, ist die minimale Distanz
$d_{\text{min}}$ sehr gering. Ist dies der Fall, so kann angenommen
werden, dass sich der Urpsrungspunkt $\bm{x}$ in einer Penumbra-Region
befindet, was sich auf die Schattierung des Punktes auswirkt: Je
knapper der Schattenfühler eine Oberfläche nicht geschnitten hat, desto
stärker wird der Punkt schattiert. Zusätzlich wird die Distanz des
Ursprungspunktes einbezogen. Je geringer diese ist, desto stärker wird
der Punkt schattiert.

Durch Hinzufügen eines Skalierungsfaktors kann ein Schattenwurf härter
oder weicher gezeichnet werden.

\begin{lstlisting}[language=Python,caption={Algorithmus zur Berechnung
        von weichen Schatten.},label={alg:sphere_tracing_soft_shadows},captionpos=b,emph={calc_soft_shadows}]
def calc_soft_shadows():
    min_distance          = 0.01
    max_distance          = 9001
    shadow_ray_distance   = min_distance
    estimated_distance    = 0
    convergence_precision = 0.000001
    shadow                = 1.0
    scale                 = 32.0

    while shadow_ray_distance < max_distance:
        # sd_sphere is a signed distance function defining the implicit
        # surface, # cast_ray defines the ray equation given the current travelled /
        # marched distance of the ray
        estimated_distance = sd_sphere(cast_ray(shadow_ray_distance))

        if estimated_distance < convergence_precision:
            # the estimated distance is already smaller than the desired
            # precision of the convergence, so return zero (0) as we
            # have an intersection and therefore 'full' shadow
            return 0

        penumbra_factor = estimated_distance / shadow_ray_distance
        shadow = min(shadow, scale * penumbra_factor)
        shadow_ray_distance = shadow_ray_distance + estimated_distance

    # When we reach this point, there was no full intersection between
    # the ray and a implicit surface, so not entirely shadowed, so
    # return current shadow value
    return shadow
\end{lstlisting}
